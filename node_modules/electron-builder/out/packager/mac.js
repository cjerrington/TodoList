"use strict";

const fs_extra_p_1 = require("fs-extra-p");
const path = require("path");
const plist_1 = require("plist");
const bluebird_1 = require("bluebird");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../util/awaiter");
function doRename(basePath, oldName, newName) {
    return fs_extra_p_1.rename(path.join(basePath, oldName), path.join(basePath, newName));
}
function moveHelpers(frameworksPath, appName) {
    return bluebird_1.Promise.map([" Helper", " Helper EH", " Helper NP"], suffix => {
        const executableBasePath = path.join(frameworksPath, `Electron${ suffix }.app`, "Contents", "MacOS");
        return doRename(executableBasePath, `Electron${ suffix }`, appName + suffix).then(() => doRename(frameworksPath, `Electron${ suffix }.app`, `${ appName }${ suffix }.app`));
    });
}
function filterCFBundleIdentifier(identifier) {
    // Remove special characters and allow only alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.)
    // Apple documentation: https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070
    return identifier.replace(/ /g, "-").replace(/[^a-zA-Z0-9.-]/g, "");
}
function createApp(opts, appOutDir, initializeApp) {
    return __awaiter(this, void 0, void 0, function* () {
        const appInfo = opts.appInfo;
        const appFilename = appInfo.productFilename;
        const contentsPath = path.join(appOutDir, "Electron.app", "Contents");
        const frameworksPath = path.join(contentsPath, "Frameworks");
        const appPlistFilename = path.join(contentsPath, "Info.plist");
        const helperPlistFilename = path.join(frameworksPath, "Electron Helper.app", "Contents", "Info.plist");
        const helperEHPlistFilename = path.join(frameworksPath, "Electron Helper EH.app", "Contents", "Info.plist");
        const helperNPPlistFilename = path.join(frameworksPath, "Electron Helper NP.app", "Contents", "Info.plist");
        const result = yield bluebird_1.Promise.all([initializeApp(), bluebird_1.Promise.map([appPlistFilename, helperPlistFilename, helperEHPlistFilename, helperNPPlistFilename, opts["extend-info"]], it => it == null ? it : fs_extra_p_1.readFile(it, "utf8"))]);
        const fileContents = result[1];
        const appPlist = plist_1.parse(fileContents[0]);
        const helperPlist = plist_1.parse(fileContents[1]);
        const helperEHPlist = plist_1.parse(fileContents[2]);
        const helperNPPlist = plist_1.parse(fileContents[3]);
        // If an extend-info file was supplied, copy its contents in first
        if (fileContents[4] != null) {
            Object.assign(appPlist, plist_1.parse(fileContents[4]));
        }
        // Now set fields based on explicit options
        const appBundleIdentifier = filterCFBundleIdentifier(appInfo.id);
        const helperBundleIdentifier = filterCFBundleIdentifier(opts["helper-bundle-id"] || `${ appBundleIdentifier }.helper`);
        const buildVersion = appInfo.buildVersion;
        const appCategoryType = opts["app-category-type"];
        const humanReadableCopyright = appInfo.copyright;
        appPlist.CFBundleDisplayName = appInfo.productName;
        appPlist.CFBundleIdentifier = appBundleIdentifier;
        appPlist.CFBundleName = appInfo.productName;
        helperPlist.CFBundleDisplayName = `${ appInfo.productName } Helper`;
        helperPlist.CFBundleIdentifier = helperBundleIdentifier;
        appPlist.CFBundleExecutable = appFilename;
        helperPlist.CFBundleName = appInfo.productName;
        helperPlist.CFBundleExecutable = `${ appFilename } Helper`;
        helperEHPlist.CFBundleDisplayName = `${ appFilename } Helper EH`;
        helperEHPlist.CFBundleIdentifier = `${ helperBundleIdentifier }.EH`;
        helperEHPlist.CFBundleName = `${ appInfo.productName } Helper EH`;
        helperEHPlist.CFBundleExecutable = `${ appFilename } Helper EH`;
        helperNPPlist.CFBundleDisplayName = `${ appInfo.productName } Helper NP`;
        helperNPPlist.CFBundleIdentifier = `${ helperBundleIdentifier }.NP`;
        helperNPPlist.CFBundleName = `${ appInfo.productName } Helper NP`;
        helperNPPlist.CFBundleExecutable = `${ appFilename } Helper NP`;
        if (appInfo.version != null) {
            appPlist.CFBundleShortVersionString = appPlist.CFBundleVersion = appInfo.version;
        }
        if (buildVersion != null) {
            appPlist.CFBundleVersion = buildVersion;
        }
        if (opts.protocols && opts.protocols.length) {
            appPlist.CFBundleURLTypes = opts.protocols.map(function (protocol) {
                return {
                    CFBundleURLName: protocol.name,
                    CFBundleURLSchemes: [].concat(protocol.schemes)
                };
            });
        }
        if (appCategoryType) {
            appPlist.LSApplicationCategoryType = appCategoryType;
        }
        if (humanReadableCopyright) {
            appPlist.NSHumanReadableCopyright = humanReadableCopyright;
        }
        const promises = [fs_extra_p_1.writeFile(appPlistFilename, plist_1.build(appPlist)), fs_extra_p_1.writeFile(helperPlistFilename, plist_1.build(helperPlist)), fs_extra_p_1.writeFile(helperEHPlistFilename, plist_1.build(helperEHPlist)), fs_extra_p_1.writeFile(helperNPPlistFilename, plist_1.build(helperNPPlist)), doRename(path.join(contentsPath, "MacOS"), "Electron", appPlist.CFBundleExecutable)];
        if (opts.icon != null) {
            promises.push(fs_extra_p_1.copy(opts.icon, path.join(contentsPath, "Resources", appPlist.CFBundleIconFile)));
        }
        yield bluebird_1.Promise.all(promises);
        yield moveHelpers(frameworksPath, appFilename);
        yield fs_extra_p_1.rename(path.dirname(contentsPath), path.join(appOutDir, `${ appFilename }.app`));
    });
}
exports.createApp = createApp;
//# sourceMappingURL=mac.js.map
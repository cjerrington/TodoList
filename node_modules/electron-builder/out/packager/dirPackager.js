"use strict";

const bluebird_1 = require("bluebird");
const fs_extra_p_1 = require("fs-extra-p");
const log_1 = require("../util/log");
const downloadElectron = bluebird_1.Promise.promisify(require("electron-download"));
const extract = bluebird_1.Promise.promisify(require("extract-zip"));
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../util/awaiter");
const supportedPlatforms = {
    // Maps to module ID for each platform (lazy-required if used)
    darwin: "./mac",
    linux: "./linux",
    mas: "./mac",
    win32: "./win32"
};
function createDownloadOpts(opts, platform, arch, electronVersion) {
    const downloadOpts = Object.assign({
        cache: opts.cache,
        strictSSL: opts["strict-ssl"]
    }, opts.download);
    subOptionWarning(downloadOpts, "download", "platform", platform);
    subOptionWarning(downloadOpts, "download", "arch", arch);
    subOptionWarning(downloadOpts, "download", "version", electronVersion);
    return downloadOpts;
}
function subOptionWarning(properties, optionName, parameter, value) {
    if (properties.hasOwnProperty(parameter)) {
        log_1.warn(`${ optionName }.${ parameter } will be inferred from the main options`);
    }
    properties[parameter] = value;
}
function pack(opts, out, platform, arch, electronVersion, initializeApp) {
    return __awaiter(this, void 0, void 0, function* () {
        const zipPath = (yield bluebird_1.Promise.all([downloadElectron(createDownloadOpts(opts, platform, arch, electronVersion)), fs_extra_p_1.emptyDir(out)]))[0];
        yield extract(zipPath, { dir: out });
        yield require(supportedPlatforms[platform]).createApp(opts, out, initializeApp);
    });
}
exports.pack = pack;
//# sourceMappingURL=dirPackager.js.map
"use strict";

const bluebird_1 = require("bluebird");
const gitHubRequest_1 = require("./gitHubRequest");
const log_1 = require("../util/log");
const util_1 = require("../util/util");
const path_1 = require("path");
const fs_extra_p_1 = require("fs-extra-p");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../util/awaiter");
class BintrayPublisher {
    constructor(user, apiKey, version, packageName) {
        let repo = arguments.length <= 4 || arguments[4] === undefined ? "generic" : arguments[4];
        let options = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

        this.user = user;
        this.version = version;
        this.packageName = packageName;
        this.repo = repo;
        this.options = options;
        this.auth = `Basic ${ new Buffer(`${ user }:${ apiKey }`).toString("base64") }`;
        this.basePath = `/packages/${ this.user }/${ this.repo }/${ this.packageName }`;
        this._versionPromise = this.init();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield gitHubRequest_1.bintrayRequest(`${ this.basePath }/versions/${ this.version }`, this.auth);
            } catch (e) {
                if (e instanceof gitHubRequest_1.HttpError && e.response.statusCode === 404) {
                    if (this.options.publish !== "onTagOrDraft") {
                        log_1.log(`Version ${ this.version } doesn't exist, creating one`);
                        return this.createVersion();
                    } else {
                        log_1.log(`Version ${ this.version } doesn't exist, artifacts will be not published`);
                    }
                }
                throw e;
            }
        });
    }
    createVersion() {
        return gitHubRequest_1.bintrayRequest(`${ this.basePath }/versions`, this.auth, {
            name: this.version
        });
    }
    upload(file, artifactName) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = artifactName || path_1.basename(file);
            const version = yield this._versionPromise;
            if (version == null) {
                util_1.debug(`Version ${ this.version } doesn't exist and is not created, artifact ${ fileName } is not published`);
                return;
            }
            const fileStat = yield fs_extra_p_1.stat(file);
            let badGatewayCount = 0;
            for (let i = 0; i < 3; i++) {
                try {
                    return yield gitHubRequest_1.doApiRequest({
                        hostname: "api.bintray.com",
                        path: `/content/${ this.user }/${ this.repo }/${ this.packageName }/${ version.name }/${ fileName }`,
                        method: "PUT",
                        headers: {
                            "User-Agent": "electron-builder",
                            "Content-Length": fileStat.size,
                            "X-Bintray-Override": "1",
                            "X-Bintray-Publish": "1"
                        }
                    }, this.auth, gitHubRequest_1.uploadFile.bind(this, file, fileStat, fileName));
                } catch (e) {
                    if (e instanceof gitHubRequest_1.HttpError && e.response.statusCode === 502 && badGatewayCount++ < 3) {
                        continue;
                    }
                    throw e;
                }
            }
        });
    }
    //noinspection JSUnusedGlobalSymbols
    deleteRelease() {
        if (!this._versionPromise.isFulfilled()) {
            return bluebird_1.Promise.resolve();
        }
        const version = this._versionPromise.value();
        if (version == null) {
            return bluebird_1.Promise.resolve();
        }
        return gitHubRequest_1.bintrayRequest(`/packages/${ this.user }/${ this.repo }/${ this.packageName }/versions/${ version.name }`, this.auth, null, "DELETE");
    }
}
exports.BintrayPublisher = BintrayPublisher;
//# sourceMappingURL=BintrayPublisher.js.map